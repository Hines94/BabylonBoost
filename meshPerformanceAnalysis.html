<!DOCTYPE html>
<html lang="en">

<head>
    <title>BabylonJs Mesh Performance Investigation</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    {% include navbar.html %}
    <div class="container main">
        <header>
            <h1>BabylonJs Mesh Performance Investigation</h1>
        </header>
        <section>
            <h2>Investigation into BabylonJs Mesh Performance</h2>
            <p>A small investigation to find what is the best course of action for upgrading the async mesh system to
                networked.</p>
            <section>
                <h3>Implementation Ideas</h3>
                <p>Since the instanced static mesh is extremely strong in multiple instances and fairly equal on single
                    instance multiple meshes it is the clear winner. The system will require some re-writing to enable
                    easy passing from server to client and still enable the client to create client side meshes.</p>
            </section>
            <section>
                <h3>General</h3>
                <ul>
                    <li>Thin mesh instances are used for all Static Meshes</li>
                    <li>All thin mesh movements are queued false for thinInstanceSetMatrixAt and run at end of frame
                    </li>
                    <li>Clones used for all Skeletal Meshes</li>
                    <li>Instances get added with a buffer (5/10/30) if more required</li>
                    <li>Instances that are no longer in use get hidden instantly (below map)</li>
                    <li>Meshes are set as is_visible = false if no instances are visible this frame (makes them free)
                    </li>
                    <li>If no description exists for mesh setup then makes new description and adds to fast dictionary
                    </li>
                </ul>
            </section>
            <section>
                <h3>Server Side Ideas</h3>
                <ul>
                    <li>“NetworkedMeshInstance” component that stores just mesh and materials</li>
                    <li>Optional boolean to load on server side</li>
                    <li>Simply change materials etc and set dirty to network changes down to client</li>
                    <li>Blank materials in actuality (no mats needed!)</li>
                </ul>
            </section>
            <section>
                <h3>Client Side Ideas</h3>
                <ul>
                    <li>“NetworkedMeshInstance” translated into a mesh</li>
                    <li>“NetworkedMeshClone” translated into a mesh</li>
                    <li>If a networked item is destroyed, the mesh is removed!</li>
                    <li>If networked mesh changes then old mesh is removed!</li>
                </ul>
            </section>
            <section>
                <h3>Culling System</h3>
                <ul>
                    <li>Uses a hash grid for fast checks</li>
                    <li>On camera (or players server?) move, checks if we are through to next grid or same as prior</li>
                    <li>New grid items are added and old grid items (on other side) removed</li>
                </ul>
            </section>
        </section>
        <section>
            <h2>Performance Observations</h2>
            <p>In general thin-instance is the winner in most situations. The performance for duplicates with the same
                materials is superb and the performance for single instances of mesh/material combinations is similar to
                regular meshes. The main drawback is adding to/deleting these meshes, but with some careful management
                around hiding and later removing the meshes it should have minimal impact.</p>
        </section>
        <section>
            <h2>General Observations</h2>
            <ul>
                <li>Triangle count seriously impacts performance (far more than other engines like Unity/Unreal)</li>
                <li>Meshes will need to be as small as possible (tri count) to keep performance good, but this is in line
                    with size goals for async mesh loading anyway</li>
            </ul>
        </section>
        <section>
            <h3>Thin Instances</h3>
            <ul>
                <li>Still render multiples off-screen</li>
                <li>Large performance penalty for adding/removing on regular basis (tanks frames to <30 for 1 change per
                    frame)</li>
                <li>Strong performance for large number of single mesh</li>
                <li>Similar performance to with only 1 instance (around 10% less)</li>
                <li>Colour data small(ish) impact</li>
            </ul>
        </section>
        <section>
            <h3>Instanced Meshes</h3>
            <ul>
                <li>Expensive(ish) to create instance but cheap to delete</li>
                <li>Performance in-between regular mesh and instance</li>
            </ul>
        </section>
        <section>
            <h3>Regular Mesh</h3>
            <ul>
                <li>Strongest performance if only 1 per instance</li>
                <li>Performance tails off extremely hard with multiples</li>
            </ul>
        </section>
        <section>
            <h3>Clones</h3>
            <ul>
                <li>Similar to regular mesh in most situations</li>
                <li>Multiples performance gains only marginal</li>
            </ul>
        </section>
    </div>
    <footer>
        <p>BabylonJs Mesh Performance Investigation © 2023. All rights reserved.</p>
    </footer>
</body>

</html>
