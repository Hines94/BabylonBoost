//@ts-ignore
import * as fs from 'fs';
//@ts-ignore
import * as path from 'path';
import {AllComponents, AllEnums, AllOtherStructs, CompPropTags, CompTags, ComponentProperty, StructDetails, StructInheritsFromComponent,} from "../Utils/ComponentPropertyReader"
import { buildPath } from '../Autogenerator';
import { DeleteFile, FileIncludesString, WriteFile, WriteFileIfChanged } from '../Utils/InvalidFileRemover';
import { GetMacroStringTags } from '../Utils/CommentMacroFinder';
import * as tsj from "ts-json-schema-generator";
import $RefParser from 'json-schema-ref-parser';

export async function FinishClientAutoTypings() {
    var output = `/*\n\tAutogenerated from 'ClientTypingsAutogenerator.ts'. Makes keeping track of types server->client easier.\n\tMark with CPROPERTY(NOTYPINGS) to stop auto addition to typings \n\tUse TODO: class CustomClientTyping inheritance to change the type of a data item \n*/\n\n`;
    output += "type PrefabString = string; //TODO: Custom typings as this is manually set! \n\n";
    output += "type EntityData = number; //TODO: Custom typings as this is manually set! \n\n";
    GenerateComponents();
    output += `\n/* -------- DATA ITEMS -------- */\n\n`;
    GenerateCustomDataTypes();
    output += `\n/* -------- ENUMS -------- */\n\n`;
    GenerateEnums();
    
    //Write to file
    const outputFile = path.join(buildPath,"ClientTypings_autogenerated.ts");

    //Schema is really slow so first check if anything has changed in output file
    if(FileIncludesString(outputFile,output)){
        return;
    }
    
    await GenerateSchema();
    if(WriteFileIfChanged(outputFile,output) === false) {
        return;
    }

    async function GenerateSchema() {
        const tempFile = path.join(buildPath, "temp_ClientTypings_autogenerated.ts");
        WriteFile(tempFile, output);
        //Create schema
        const config = {
            path: tempFile,
            tsconfig: '../tsconfig.json',
            type: 'EntVector3',
        };
        output += `\n/* -------- JSON Schema -------- */\n\n`;
        const schemas:{[id:string]:string} = {};
        for(var i = 0; i < generatedComponentDescriptions.length;i++){
            var comp = generatedComponentDescriptions[i];
            config.type = comp;
        
            const generator = tsj.createGenerator(config);
            let schema = generator.createSchema(config.type);
            let derefSchema = await ($RefParser as any).bundle(schema);
            schemas[comp] = JSON.stringify( derefSchema, null, 4);
        }

        output += "/** Schema types so we can dynamically generate data for components */\n";
        output += "export const componentSchemas: {[id:string]:string} = " + JSON.stringify(schemas, null, 4);
        DeleteFile(tempFile);
    }

    function GenerateCustomDataTypes() {
        const keys = Object.keys(AllOtherStructs);
        keys.forEach(element => {
            if(customDataItems.includes(element)){
                output = GenerateComponentDescription(AllOtherStructs[element],output);
            }
        });
    }

    function GenerateComponents() {
        const comps = Object.keys(AllComponents);
        var genereatedComps:string[] = [];
        for (var i = 0; i < comps.length; i++) {
            const compData = AllComponents[comps[i]];
            output = GenerateComponentDescription(compData, output);
            if(compData.structTags.includes(CompTags.NOTYPINGS) === false) {
                genereatedComps.push(compData.name);
            }
        }
        output += "/** List of valid component types to add to an Entity */\n";
        output += "export const ComponentTypes = [\n";
        for (var i = 0; i < genereatedComps.length; i++) {
            output += "\t" + genereatedComps[i] + ",\n";
        }
        output += "];\n";
    }

    function GenerateEnums() {
        const enums = Object.keys(AllEnums);
        for (var i = 0; i < enums.length; i++) {
            if(customDataItems.includes(enums[i]) === false) continue;
            const enumData = AllEnums[enums[i]];
            output += "enum " + enums[i] + " {\n";
            for(var j = 0; j < enumData.length; j++){
                output += "\t" + enumData[j] + ",\n";
            }
            output += "};\n";
        }
    }
}

function getCleanComment(comment:string) : string {
    return comment.replace("//","").replace("/*","").replace("*/","");
}


const generatedComponentDescriptions:string[] = [];
function GenerateComponentDescription(compData: StructDetails, output: string) {
    if(compData.structTags.includes(CompTags.NOTYPINGS)) {
        return output;
    }
    if (compData.comment) {
        output += "/** " + getCleanComment(compData.comment.text) + " */\n";
    }
    generatedComponentDescriptions.push(compData.name);
    output += "export class " + compData.name + " {\n";
    //Add properties
    for (var j = 0; j < compData.properties.length; j++) {
        const property = compData.properties[j];
        if(!property.isCPROPERTY) {
            continue;
        }
        if(property.tags.includes(CompPropTags.NOTYPINGS)) {
            continue;
        }
        //TODO: Change this to all structs (instead of components only) if we are able to specify net/save properties on sub comps
        if(StructInheritsFromComponent(compData) && !property.tags.includes(CompPropTags.SAVE)) {
            continue;
        }
        //Comments + Editor property specifiers
        var comment = "";
        if (property.comment) {
            comment = getCleanComment(property.comment);
        }
        GetPropertyEditorSpecifiers(property);
        if(comment !== "") {
            output += "\t/** " + comment + " */\n";
        }
        //Actual property
        output += "\t" + property.name + ": " + convertTypeToTypescript(property.type) + ";\n";
    }
    //Add required components (Editor)
    output += FindRequiredComponents(compData);
    output += "}\n\n";
    return output;

    function GetPropertyEditorSpecifiers(property: ComponentProperty) {
        if (property.tags.includes(CompPropTags.EDREAD)) {
            comment += "__EDITORREADONLY__";
        }
    }
}

const customDataItems:string[] = [];

function convertTypeToTypescript(type:string) {
    // Remove pointer references
    type = type.replace(/\*/g, '').trim();

    //Check for containers
    const containerMatch = type.match(/^(std::map|std::unordered_map|std::set|std::unordered_set|std::vector|std::list)<(.+)>$/);
    if (containerMatch) {
        // The type is in a container
        const containerType = containerMatch[1];
        const valueType = containerMatch[2];
        if(containerType == "std::map" || containerType == "std::unordered_map") {
            return `{[key: string]: ${convertTypeToTypescript(valueType)}}`;
        }
        if(containerType == "std::set" || containerType == "std::unordered_set") {
            return `${convertTypeToTypescript(valueType)}[]`;
        }
        if(containerType=="std::vector" || containerType=="std::list") {
            return `${convertTypeToTypescript(valueType)}[]`;
        }
    }

    //Base value
    if(type == "int" || type == "float" || type == "double" || type == "long" 
    || type == "short" || type == "size_t" || type == "uint" || type == "ulong"
    || type == "ushort" || type == "uint_8" || type == "uint_16" || type == "uint_32" 
    || type == "uint8_t" || type == "int8_t"|| type == "uint16_t" || type == "int16_t" 
    || type == "uint32_t" || type == "int32_t" || type == "uint64_t" || type == "int64_t") {
        return "number";
    }
    if(type == "bool") {
        return "boolean";
    }
    if(type == "std::string" || type == "std::wstring" || type == "std::u16string" || type == "std::u32string") {
        return "string";
    }
    if(type == "unsigned char") {
        return "number";
    }

    //All fail
    if(customDataItems.includes(type) == false){customDataItems.push(type);}
    return type;
}

function isValidRequire(name:string):boolean {
    const keys = Object.keys(AllComponents);
    return keys.includes(name);
}

function FindRequiredComponents(details:StructDetails) : string {
    var ret = "";

    for(var i = 0; i < details.macros.length; i++) {
        if(details.macros[i].text.includes("REQUIRE_OTHER_COMPONENTS")) {
            const tags = GetMacroStringTags(details.macros[i].text,isValidRequire);
            ret += "\tstatic GetRequiredComponents() { return [" + tags.join(",\n") + "]; }\n";
        }
    }

    return ret;
}
