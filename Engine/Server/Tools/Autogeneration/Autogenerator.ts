//@ts-ignore
import * as fs from 'fs';
//@ts-ignore
import * as path from 'path';
import { RunBodyAutogeneration, RunBodyPrepass } from './BodyMethods/BodyAutogeneration';
import { UpdateStructsProperties } from './Utils/ComponentPropertyReader';
import { GenerateComponentLoader } from './Utils/ComponentLoadGenerator';
import { FinishClientAutoTypings } from './ClientTypings/ClientTypingsAutogenerator';
import { RemoveInvalidFiles } from './Utils/InvalidFileRemover';
import { RunHeaderAutogeneration } from './HeaderMethods/HeaderAutogeneration';
import { GenerateTrackedVariableSpecialisations } from './TrackedVariables/TrackedVariableSetup';

export const userSourcePath = "../../../../../Source/CppSource";
export const sourcePath = "../../../src";
export const buildPath = "../../../build/Autogeneration";

//Process a file and search for any candidates for autogeneration
function processFile(basePath:string,filePath: string) {
    //Get properties and check if any point in creation
    let code = fs.readFileSync(filePath, 'utf-8');
    UpdateStructsProperties(code,basePath,filePath);
    RunBodyAutogeneration(code,basePath,filePath);
    RunHeaderAutogeneration(code,basePath,filePath);
}

export function CreateAutogenFile(basePath:string ,filePath: string,extension:string = ".cpp") {
    let fileNameExten = path.basename(filePath);
    let fileName = path.basename(filePath, path.extname(filePath)); // get the file name without extension
    let relativeDir = path.relative(basePath, path.dirname(filePath)); // get the relative directory path of the file
    let outputDir = path.join(buildPath, relativeDir); // get the corresponding directory in the build folder
    fs.mkdirSync(outputDir, { recursive: true }); // create the directory if it doesn't exist
    let outputFile = path.join(outputDir, `${fileName}_autogenerated${extension}`);
    return { relativeDir, fileName, fileNameExten, outputFile };
}

//Process a directory and search for any candidates for autogeneration
export function RecursiveDirectoryProcess(basePath:string,dirPath: string,processMethod:(basePath:string,filePath:string)=>void, fileTypes:string[]) {
    if(!fs.existsSync(basePath)) {
        console.error("Given faulty base path: " + basePath);
        process.exit(1);
    }
    
    const entries = fs.readdirSync(dirPath, { withFileTypes: true });

    for (const entry of entries) {
        if (entry.isDirectory()) {
            RecursiveDirectoryProcess(basePath,path.join(dirPath, entry.name),processMethod,fileTypes);
        } else if (entry.isFile()) {
            var typeFound = false;
            fileTypes.forEach(ft=>{
                if(entry.name.endsWith(ft)){
                    typeFound = true;
                }
            })
            if(typeFound) {
                processMethod(basePath,path.join(dirPath, entry.name));
            }
        }
    }
}

async function RunAutogenerator() {
    //Prepasses
    RunBodyPrepass();
    //Autogeneration
    RecursiveDirectoryProcess(sourcePath,sourcePath,processFile,[".h",".hpp"]);
    RecursiveDirectoryProcess(userSourcePath,userSourcePath,processFile,[".h",".hpp"]);
    GenerateComponentLoader();
    FinishClientAutoTypings();
    GenerateTrackedVariableSpecialisations();
    RemoveInvalidFiles();
}

//Actual autogeneration
console.time('Autogenerator Runtime');
RunAutogenerator().then(()=>{
    console.timeEnd('Autogenerator Runtime');
})
