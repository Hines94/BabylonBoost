import { HigherarchyHTML } from "./HigherarchyHTML";
import { ContentItem, GetFullNameOfObject } from "../ContentBrowser/ContentItem";
import { OpenNewWindow } from "@BabylonBurstClient/HTML/HTMLWindowManager";
import { WaitForEvent } from "@BabylonBurstClient/HTML/HTMLUtils";
import { ShowToastNotification } from "@BabylonBurstClient/HTML/HTMLToastItem";
import {
    EntitySpecification,
    GetComponent,
    LoadEntitiesFromMsgpackFormat,
} from "@BabylonBurstClient/EntitySystem/EntityMsgpackConverter";
import { ShowContextMenu } from "@BabylonBurstClient/HTML/HTMLContextMenu";
import { ContentStorageBackend } from "../ContentBrowser/ContentBrowserHTML";
import { AddOptionToEditorTopMenu } from "../../Utils/EditorTopMenu";
import { SetupAllEditorVisualisations } from "../HTMLUtils/VisualAidUtils";
import { decode, encode } from "@msgpack/msgpack";
import { PrefabPackedType } from "@BabylonBurstClient/EntitySystem/PrefabPackedType";

import { GetAllWasmModules } from "@BabylonBurstClient/WASM/ServerWASMModule";
import { Prefab } from "@BabylonBurstClient/Autogenerated/babylonburst_ServerTypings_autogenerated";

/** Used for specifically loading prefabs into a seperate window */
export class PrefabHigherarchyHTML extends HigherarchyHTML {
    /** Included as "PrefabId" in prefab json data */
    prefabUUID: string;

    async LoadPrefabIntoHigherarchy(prefab: ContentItem, storageBackend: ContentStorageBackend) {
        const higherarchy = this;

        this.Displayer = OpenNewWindow(
            "PrefabWindows_" + prefab.readableName,
            "EditorSections/PrefabDisplayer",
            prefab.readableName
        );
        if (!this.Displayer) {
            return;
        }

        this.windowDoc = this.Displayer.window.document;
        await WaitForEvent("PrefabDisplayerSetup", this.windowDoc);
        this.setupEditorPanel();
        this.windowDoc.getElementById("ContentBrowser").remove(); //TODO: if it becomes useful again show

        //Setup new game ecosystem so we can render any prefab items
        this.setupHigherarchyEcosystem();

        //Load new prefab
        const prefabData = decode(prefab.data) as PrefabPackedType;
        this.prefabUUID = prefabData.prefabID;
        this.allEntities = LoadEntitiesFromMsgpackFormat(prefabData.prefabData);
        (this.higherarchPanel.querySelector("#HigherarchTitle") as HTMLElement).innerText = prefab.readableName;

        await this.ecosystem.waitLoadedPromise;

        setupTopMenu();

        this.RegenerateHigherarchy();

        this.setupRightClick();

        //Show higherarchy panel
        this.higherarchPanel.classList.remove("hidden");

        //Prefab specific - with save/exit etc
        function setupTopMenu() {
            //Save button
            const saveEntButton = AddOptionToEditorTopMenu(higherarchy.ecosystem, "File", "Save Prefab");
            saveEntButton.addEventListener("click", () => {
                const saveData: PrefabPackedType = {
                    prefabID: higherarchy.prefabUUID,
                    prefabData: new Uint8Array(higherarchy.ecosystem.wasmWrapper.GetAllEntitiesArray(true)),
                };
                prefab.data = encode(saveData);

                console.log("------------ Saved Prefab Data ------------");
                console.log(higherarchy.ecosystem.wasmWrapper.GetAllEntities(true));
                //For direct use with c++ test files etc
                const hexString = Array.from(prefab.data, byte =>
                    ("0" + (byte as any & 0xff).toString(16)).slice(-2)
                ).join("");
                console.log(hexString);
                //For direct use with c++ test files etc
                console.log("------------- End Prefab Data -------------");

                //Save to backend
                storageBackend.saveItem(prefab);
                //Reset for each current WASM system
                GetAllWasmModules().forEach(w => {
                    w.ReloadPrefabData(GetFullNameOfObject(prefab), prefab.data);
                });
                ShowToastNotification("Entity Saved", 3000, higherarchy.windowDoc);
            });
            //Exit button
            const exitButton = AddOptionToEditorTopMenu(higherarchy.ecosystem, "File", "Exit");
            exitButton.addEventListener("click", () => {
                if (higherarchy.ecosystem.doc.defaultView.confirm("Close Prefab Editing")) {
                    higherarchy.Displayer.window.close();
                }
            });

            //Visualistaions
            SetupAllEditorVisualisations(higherarchy.ecosystem);
        }
    }

    protected override GetPrefabInsetLevel(entity: EntitySpecification): number {
        if(GetComponent(entity, Prefab) === undefined) {
            return 0;
        }
        if (GetComponent(entity, Prefab).PrefabIdentifier != this.prefabUUID) {
            return 1;
        }
        return 0;
    }

    protected override setupContextMenu(event: MouseEvent): void {
        ShowContextMenu(
            event,
            [
                {
                    name: "New Entity",
                    callback: () => {
                        this.addNewEntity();
                        this.RegenerateHigherarchy();
                    },
                },
            ],
            this.Displayer.window.document
        );
    }

    protected override addNewEntity(): number {
        const added = super.addNewEntity();
        const prefabData = new Prefab();
        prefabData.PrefabIdentifier = this.prefabUUID;
        prefabData.EntityIndex = added;
        this.allEntities[added] = {
            Prefab: prefabData,
        };
        return added;
    }
}
