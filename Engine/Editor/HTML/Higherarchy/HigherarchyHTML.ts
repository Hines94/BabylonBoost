import { SetInspectorOwner } from "../InspectorWindow/InspectorHTML";
import { RemoveClassFromAllItems, WaitForEvent } from "@BabylonBoostClient/HTML/HTMLUtils";
import { GameEcosystem } from "@BabylonBoostClient/GameEcosystem";
import { EntitySpecification, GetComponent, RawEntityData } from "@BabylonBoostClient/EntitySystem/EntityMsgpackConverter";
import { BabylonBoostEditor } from "../../BabylonBoostEditor";
import { ShowContextMenu } from "@BabylonBoostClient/HTML/HTMLContextMenu";
import { GetEditorGizmos } from "./EditorGizmos";
import { EntityInspectorHTML } from "./EntityInspectorHTML";
import { Prefab } from "@BabylonBoostClient/Autogenerated/BabylonBoost_ServerTypings_autogenerated";

/** Can display entities in a higherarchy with clickable options (delete/add etc). Also hooks into inspector. */
export class HigherarchyHTML {
    higherarchyItems: HTMLElement;
    allEntities: RawEntityData;
    Displayer: { loadingElement: Promise<HTMLDivElement>; window: Window };
    windowDoc: Document;
    inspector: HTMLElement;
    higherarchPanel: HTMLElement;
    contentOptions: HTMLElement;
    ecosystem: GameEcosystem;
    generatedEntityRows: { [entId: number]: HTMLDivElement } = {};

    protected setupHigherarchyEcosystem() {
        const gamePanel = this.windowDoc.getElementById("renderCanvas");
        this.ecosystem = new BabylonBoostEditor(gamePanel as HTMLCanvasElement, {
            noHTML: true,
        });
        const higherarchy = this;
        this.Displayer.window.addEventListener("beforeunload", function (e) {
            higherarchy.ecosystem.dispose();
        });
    }

    protected setupEditorPanel() {
        const uploader = this.windowDoc.getElementById("ContentUpload");
        uploader.classList.add("hidden");
        this.higherarchPanel = this.windowDoc.getElementById("Higherarchy");
        this.higherarchyItems = this.higherarchPanel.querySelector("#HigherarchyItems");
        this.inspector = this.windowDoc.getElementById("InspectorPanel");
        this.contentOptions = this.windowDoc.getElementById("ContentOptions");
    }

    protected setupRightClick() {
        const higherarchy = this;
        higherarchy.Displayer.window.document.addEventListener("contextmenu", ev => {
            if (ev.target != higherarchy.higherarchPanel) {
                return;
            }
            higherarchy.setupContextMenu(ev);
        });
    }

    /** Add entity etc */
    protected setupContextMenu(event: MouseEvent) {}

    /*Reload entities with default values (so we can set inspector etc with current values)*/
    RefreshDataToWASM() {
        this.allEntities = this.ecosystem.wasmWrapper.GetAllEntities(false);
    }

    /** Reset our WASM module to same as the JS data */
    RefreshWASMToData() {
        this.ecosystem.wasmWrapper.ResetEntitySystem();
        this.ecosystem.wasmWrapper.LoadMsgpackDataToExistingEntities(this.allEntities, true);
        this.ecosystem.wasmWrapper.FlushEntitySystem();
    }

    /** Rebuild Entities and entity rows */
    RegenerateHigherarchy() {
        this.RefreshWASMToData();
        this.RefreshDataToWASM();

        const entityIds = Object.keys(this.allEntities);
        //Generate new entities and higherarchy data
        for (var i = 0; i < entityIds.length; i++) {
            if (this.generatedEntityRows[parseInt(entityIds[i])] === undefined) {
                this.GenerateEntityRow(i);
            }
        }
        //Remove old entities that no longer exist
        for (let entId in this.generatedEntityRows) {
            if (entityIds.includes(entId) === false) {
                this.generatedEntityRows[entId].remove();
                delete this.generatedEntityRows[entId];
            }
        }

        this.ecosystem.wasmWrapper.FlushEntitySystem();
    }

    /** Entity row on higherarchy that lets us select and TODO: re-parent etc */
    GenerateEntityRow(i: number): HTMLDivElement {
        const entIds = Object.keys(this.allEntities);
        const entId = parseInt(entIds[i]);

        //Basic items
        const row = this.windowDoc.createElement("div");
        this.generatedEntityRows[entId] = row;
        row.style.marginTop = "2px";
        row.classList.add("higherarchyEntity");
        const entityId = this.windowDoc.createElement("p");
        entityId.innerText += "Entity " + entId;
        entityId.classList.add("higherarchEntityText");
        row.appendChild(entityId);
        this.higherarchyItems.appendChild(row);
        row.style.marginLeft = (this.GetPrefabInsetLevel(this.allEntities[entId]) * 10).toString() + "%";

        //View Entity components etc
        row.addEventListener("click", () => {
            RemoveClassFromAllItems("selectedHigherarchy", this.higherarchyItems);
            row.classList.add("selectedHigherarchy");
            this.inspector.innerHTML = "";
            this.inspector.classList.remove("hidden");
            SetInspectorOwner(row);
            this.setupInspectorForEntity(entId);
            GetEditorGizmos(this.ecosystem).SetupToEntity(entId);
            GetEditorGizmos(this.ecosystem).SetPositionGizmoEnabled();
        });
        //Entity context menu
        row.addEventListener("contextmenu", event => {
            // this.ourContentHolder.unclickAllItems();
            // this.ourSelectable.classList.add("selectedContent");
            ShowContextMenu(
                event,
                [
                    {
                        name: "Delete Entity",
                        callback: () => {
                            if (this.windowDoc.defaultView.confirm("Delete Entity " + entId + "?")) {
                                row.remove();
                                delete this.allEntities[entId];
                                this.RegenerateHigherarchy();
                            }
                        },
                    },
                ],
                this.inspector.ownerDocument
            );
        });
        return row;
    }

    protected GetPrefabInsetLevel(entity: EntitySpecification): number {
        if (GetComponent(entity, Prefab)) {
            return 1;
        }
        return 0;
    }

    protected addNewEntity(): number {
        const keys = Object.keys(this.allEntities);
        var found = true;
        var i = 1;
        while (found) {
            if (keys.includes(i.toString())) {
                i++;
                continue;
            }
            found = false;
        }
        this.allEntities[i] = {};
        return i;
    }

    addComponentToEntity(entityId: number, compType: any, allEntComps: HTMLElement): boolean {
        const entity = this.allEntities[entityId];
        if (entity[compType.name] !== undefined) {
            return true;
        }

        //Add other components
        if (compType.GetRequiredComponents) {
            const otherComponents = compType.GetRequiredComponents();
            for (var i = 0; i < otherComponents.length; i++) {
                if (!this.addComponentToEntity(entityId, otherComponents[i], allEntComps)) {
                    return false;
                }
            }
        }

        //Set component as added
        entity[compType.name] = {};
        this.refreshInspectorIfEntity(entityId);

        return true;
    }

    currrentInspector: EntityInspectorHTML;
    refreshInspectorIfEntity(entityId: number) {
        if (this.currrentInspector === undefined) {
            return;
        }
        if (this.currrentInspector.entityId !== entityId) {
            return;
        }
        this.setupInspectorForEntity(entityId);
    }

    /** For a given entity setup our inspector so we can see what components are present */
    setupInspectorForEntity(entityId: number) {
        if (this.currrentInspector) {
            this.currrentInspector.dispose();
        }
        this.currrentInspector = new EntityInspectorHTML(this, entityId);
    }
}
