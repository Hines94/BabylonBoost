import { ContentItem, ContentItemType, GetFullNameOfObject } from "../HTML/ContentBrowser/ContentItem";
import { ModelSpecifier } from "@BabylonBurstClient/Autogenerated/babylonburst_ServerTypings_autogenerated";
import { Observable, Scene } from "@babylonjs/core";
import { AsyncDataType, AsyncStaticMeshDefinition, AsyncZipPuller, SceneAsyncLoader } from "@BabylonBurstClient/AsyncAssets";


export type ModelInformation = {
    specifier:ModelSpecifier;
    materialsNum:number;
}

/** Paths and material number for all models */
export var ModelPaths:ModelInformation[] = [];
export const onModelPathsChangeObserver = new Observable<ModelInformation[]>();

export function GatherAllModelPaths(allItemsTopLevel:ContentItem,scene:Scene) {
    ModelPaths = [];
    GetAllModelPathsRecurs(allItemsTopLevel,scene);
}


function GetAllModelPathsRecurs(itemsFolder:ContentItem,scene:Scene) {
    //Recursive check all
    const itemsId = Object.keys(itemsFolder.containedItems);
    
    itemsId.forEach(element => {
        const item = itemsFolder.containedItems[element];
        if(item.category === ContentItemType.Model) {
            GatherModelPaths(item,scene);
        }
        if(item.category === ContentItemType.Folder) {
            GetAllModelPathsRecurs(item,scene);
        }
    });
}

async function GatherModelPaths(item:ContentItem,scene:Scene) {
    if(item.category !== ContentItemType.Model) {
        return;
    }
    const fullPath = GetFullNameOfObject(item);
    //Load all files 
    const puller = AsyncZipPuller.GetOrFindAsyncPuller(fullPath,AsyncDataType.string);
    await puller.GetFinishedPromise();
    for(var s = 0; s < puller.numFiles;s++) {
        var sceneLoader = AsyncStaticMeshDefinition.GetAsyncMeshLoader(scene,fullPath,s);
        if(!sceneLoader) {
            sceneLoader = new SceneAsyncLoader(fullPath,s,scene);
        }
        await sceneLoader.performAsyncLoad();   
        const uniques = sceneLoader.extractUniqueMeshes();
        const meshNames = Object.keys(uniques);
        for(var m = 0; m < meshNames.length;m++) {
            const meshName = meshNames[m];
            ModelPaths.push({materialsNum:uniques[meshName],specifier:{FilePath:fullPath,MeshName:meshName,FileIndex:s}});
        }
        onModelPathsChangeObserver.notifyObservers(ModelPaths);
    }
}