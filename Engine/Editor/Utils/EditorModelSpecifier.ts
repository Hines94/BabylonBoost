import { ContentItem, ContentItemType } from "../HTML/ContentBrowser/ContentItem";
import { ModelSpecifier } from "@BabylonBurstClient/Autogenerated/babylonburst_ServerTypings_autogenerated";
import { Observable, Scene } from "@babylonjs/core";
import { AsyncDataType, AsyncStaticMeshDefinition, AsyncZipPuller, SceneAsyncLoader } from "@BabylonBurstClient/AsyncAssets";
import { GetAllEditorObjectsOfType } from "./ContentTypeTrackers";


export type ModelInformation = {
    specifier:ModelSpecifier;
    materialsNum:number;
}

/** Paths and material number for all models */
export var ModelPaths:ModelInformation[] = [];
export const onModelPathsChangeObserver = new Observable<ModelInformation[]>();

/** Given a way to get the model (file path etc) try to get information for it */
export function FindModelForParams(data:ModelSpecifier) : ModelInformation {
    if(data === undefined || data === null) {
        return undefined;
    }
    for(var m = 0; m < ModelPaths.length;m++){
        const model = ModelPaths[m];
        if(model.specifier.FileIndex !== data.FileIndex) {
            continue;
        }
        if(model.specifier.MeshName!== data.MeshName) {
            continue;
        }
        if(model.specifier.FilePath !== data.FilePath) {
            continue;
        }
        return model;
    }

    return undefined;
}

export function RefreshAllModelPaths(allItemsTopLevel:ContentItem,scene:Scene) {
    ModelPaths = [];
    const allModels = GetAllEditorObjectsOfType(ContentItemType.Model);
    allModels.forEach(item=>GatherModelPaths(item,scene));
}


async function GatherModelPaths(item:ContentItem,scene:Scene) {
    if(item.category !== ContentItemType.Model) {
        return;
    }
    console.error("TODO: Fix v 1912")
    // const fullPath = item.parent.getItemLocation();
    // //Load all files 
    // const puller = AsyncZipPuller.GetOrFindAsyncPuller(fullPath);
    // await puller.GetFinishedPromise();
    // for(var s = 0; s < puller.numFiles;s++) {
    //     var sceneLoader = AsyncStaticMeshDefinition.GetAsyncMeshLoader(scene,fullPath,s);
    //     if(!sceneLoader) {
    //         sceneLoader = new SceneAsyncLoader(fullPath,s,scene);
    //     }
    //     await sceneLoader.performAsyncLoad();   
    //     const uniques = sceneLoader.extractUniqueMeshes();
    //     const meshNames = Object.keys(uniques);
    //     for(var m = 0; m < meshNames.length;m++) {
    //         const meshName = meshNames[m];
    //         ModelPaths.push({materialsNum:uniques[meshName],specifier:{FilePath:fullPath,MeshName:meshName,FileIndex:s}});
    //     }
    //     onModelPathsChangeObserver.notifyObservers(ModelPaths);
    // }
}