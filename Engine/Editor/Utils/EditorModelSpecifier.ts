import { ContentItem, ContentItemType, GetFullNameOfObject } from "../HTML/ContentBrowser/ContentItem";
import { ModelSpecifier } from "@BabylonBurstClient/Autogenerated/babylonburst_ServerTypings_autogenerated";
import { Observable, Scene } from "@babylonjs/core";
import { AsyncDataType, AsyncStaticMeshDefinition, AsyncZipPuller, SceneAsyncLoader } from "@BabylonBurstClient/AsyncAssets";
import { GetAllEditorObjectsOfType } from "./ContentTypeTrackers";


export type ModelInformation = {
    specifier:ModelSpecifier;
    materialsNum:number;
}

/** Paths and material number for all models */
export var ModelPaths:ModelInformation[] = [];
export const onModelPathsChangeObserver = new Observable<ModelInformation[]>();

/** Given a way to get the model (file path etc) try to get information for it */
export function FindModelForParams(data:ModelSpecifier) : ModelInformation {
    if(!data) {
        return undefined;
    }
    return ModelPaths.find(v=>{v.specifier.FilePath === data.FilePath && v.specifier.FileIndex === data.FileIndex && v.specifier.MeshName === data.MeshName});
}

export function RefreshAllModelPaths(allItemsTopLevel:ContentItem,scene:Scene) {
    ModelPaths = [];
    const allModels = GetAllEditorObjectsOfType(ContentItemType.Model);
    allModels.forEach(item=>GatherModelPaths(item,scene));
}


async function GatherModelPaths(item:ContentItem,scene:Scene) {
    if(item.category !== ContentItemType.Model) {
        return;
    }
    const fullPath = GetFullNameOfObject(item);
    //Load all files 
    const puller = AsyncZipPuller.GetOrFindAsyncPuller(fullPath,AsyncDataType.string);
    await puller.GetFinishedPromise();
    for(var s = 0; s < puller.numFiles;s++) {
        var sceneLoader = AsyncStaticMeshDefinition.GetAsyncMeshLoader(scene,fullPath,s);
        if(!sceneLoader) {
            sceneLoader = new SceneAsyncLoader(fullPath,s,scene);
        }
        await sceneLoader.performAsyncLoad();   
        const uniques = sceneLoader.extractUniqueMeshes();
        const meshNames = Object.keys(uniques);
        for(var m = 0; m < meshNames.length;m++) {
            const meshName = meshNames[m];
            ModelPaths.push({materialsNum:uniques[meshName],specifier:{FilePath:fullPath,MeshName:meshName,FileIndex:s}});
        }
        onModelPathsChangeObserver.notifyObservers(ModelPaths);
    }
}